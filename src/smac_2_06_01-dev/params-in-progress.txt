numConvLayers int [1,3] [2]
firstConvLayerType = 
	[ConvRectifiedLinear, ConvElemWise] [ConvRectifiedLinear]
	if firstConvLayerType == ConvElemWise
		1_nonlinearity str [Rect,Sigmoid,Tanh] [Rect]
	1_output_channels int [2,64] [64]
	1_kernel_shape_1 int [1,10] [5]
	1_kernel_shape_2 int [1,10] [5]
	1_pool_shape_1 int [1,27] [2] # NOTE: currently assuming pool_shape_1/2 are ind.
	1_pool_shape_2 int [1,27] [2]
	1_pool_stride int [1,27] [2] # pool_stride is dep. so sufficient to def. 10
	1_layer_name str ConvRectifiedLinear1
	1_irange float [.01, 1] [.05]
	1_border_mode str [full, valid] [valid]
	1_include_prob float [0,1] [0]
	1_init_bias float [0,1] [0]
	1_W_lr_scale float [.01,1] [1]
	1_b_lr_scale float [.01,1] [1]
	1_left_slope float [0,10] [0]
	1_max_kernel_norm float [.01,5] [1.9365]
	1_pool_type str [max] [max]
	1_tied_b bool  [True, False] [False]
	1_kernel_stride_1 int [1,37] [2]
	1_kernel_stride_2 int [1,37] [2]
	1_monitor_style str [classification] [classification]
		
if numConvLayers == 2
	secondConvLayerType = [ConvRectifiedLinear, ConvElemWise] [ConvRectifiedLinear]
	if secondConvLayerType == ConvElemWise
		2_nonlinearity str [Rect,Sigmoid,Tanh] [Rect]
	2_output_channels int [2,64] [64]
	2_kernel_shape_1 int [1,10] [5]
	2_kernel_shape_2 int [1,10] [5]
	2_pool_shape_1 int [1,27] [2] # NOTE: currently assuming pool_shape_1/2 are ind.
	2_pool_shape_2 int [1,27] [2]
	2_pool_stride int [1,27] [2] # pool_stride is dep. so sufficient to def. 10
	2_layer_name str ConvRectifiedLinear1
	2_irange float [.01, 1] [.05]
	2_border_mode str [full, valid] [valid]
	2_include_prob float [0,1] [0]
	2_init_bias float [0,1] [0]
	2_W_lr_scale float [.01,1] [1]
	2_b_lr_scale float [.01,1] [1]
	2_left_slope float [0,10] [0]
	2_max_kernel_norm float [.01,5] [1.9365]
	2_pool_type str [max] [max]
	2_tied_b bool  [True, False] [False]
	2_kernel_stride_1 int [1,37] [2]
	2_kernel_stride_2 int [1,37] [2]
	2_monitor_style str [classification] [classification]
	
if numConvLayers == 3
	thirdConvLayerType = [ConvRectifiedLinear, ConvElemWise] [ConvRectifiedLinear]
	if thirdConvLayerType == ConvElemWise
		3_nonlinearity str [Rect,Sigmoid,Tanh] [Rect]
	3_output_channels int [2,64] [64]
	3_kernel_shape_1 int [1,10] [5]
	3_kernel_shape_2 int [1,10] [5]
	3_pool_shape_1 int [1,27] [2] # NOTE: currently assuming pool_shape_1/2 are ind.
	3_pool_shape_2 int [1,27] [2]
	3_pool_stride int [1,27] [2] # pool_stride is dep. so sufficient to def. 10
	3_layer_name str ConvRectifiedLinear1
	3_irange float [.01, 1] [.05]
	3_border_mode str [full, valid] [valid]
	3_include_prob float [0,1] [0]
	3_init_bias float [0,1] [0]
	3_W_lr_scale float [.01,1] [1]
	3_b_lr_scale float [.01,1] [1]
	3_left_slope float [0,10] [0]
	3_max_kernel_norm float [.01,5] [1.9365]
	3_pool_type str [max] [max]
	3_tied_b bool  [True, False] [False]
	3_kernel_stride_1 int [1,37] [2]
	3_kernel_stride_2 int [1,37] [2]
	3_monitor_style str [classification] [classification]
	
# Assuming final layer is SoftMax
s_n_classes int [10] [10]
s_layer_name str SoftMax
s_irange float [.01, 1] [.05]
s_istdev float [.01, 1] [.05]
s_W_lr_scale float [.01,1] [1]
s_b_lr_scale float [.01,1] [1]
s_max_row_norm float [0.1, 5] [1.9365]
s_no_affine bool [True, False] [False]
s_max_col_norm float [0.1, 5] [1.9365]
s_init_bias_target_marginals float [0,1] [0]
binary_target_dim int [10] [10]